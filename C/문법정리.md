- 변수를 선언할때 값을 지정하지 않고 단순 변수 그 자체만을 선언하는 것이 가능하다. 이때 해당 변수에는 기전 메모리 값 등의 무작위 값(쓰레기 값)이 지정되어있으므로 값 초기화를 진행해주어야 한다. 
  ```c
  int c;
  // c 라는 변수가 정수형 이라는 것만 선언. c 값에는 어떤 값이 들어가있을지 모름
  // int c = 1 등의 초기화를 같이 쓰는 것을 추천
  ```

- func() 등으로 함수를 선언할때 앞에 적는 값은 리턴값을 의미한다. 리턴값이 없는 경우 void 를 적으며 이 부분을 생략하는 것은 불가능하다.
  ```c
  // 예
  struct node {
      char c;
      struct node* p;
  };
  
  struct node* func(char* s) { ...
  // func 의 리턴값의 타입이 struct node* 라는 구조체라는 것을 의미함
  // 아무 리턴값이 없으면 voide func()
  ```

- 구조체를 정의할때 * 을 통해 포인터로 지정하면 그 포인터 값은 해당 구조체의 주소만을 의미할 뿐 해당 구조체 자체를 정의한 것이 아니다.
  ```c
  struct node h; // c, p 를 실제로 지니고 있는 구조체 변수 h
  struct node* h; // struct node 의 구조체 주소를 담을 수 있는 포인터 (초기화되지 않았으므로 쓰레기 값이 저장되어있음)
  ```

- 변수 선언 시 주의

  ```c
  struct node {
      char c;
      struct node* p;
  };
  
  struct node* h = NULL, *n;
  // h 라는 변수를 만들고 h 의 c 값에 NULL, *p 값에 *n 를 넣는 것으로 보일수있지만
  // 실제로는 구조체 주소를 담을수 있는 포인터 *h 는 NULL 로 초기화 하고, *n 은 쓰레기값을 지니고있는 비초기화 상태의 구조체 주소 포인터이다.
  
  struct node h = NULL, *n;
  // 포인터 h 를 만드는 것이 아닌 변수 h 를 만드는 것이므로 h.c 에 NULL, h.p 에 *n 을 넣는 것으로 보이지만
  // 실제로는 구조체 변수 h 와 구조체 주소 포인터 *n 을 만드는 것이므로
  // 구조체 변수 자체를 NULL 로 초기화하는 것은 불가능하여 문법상 에러 발생
  
  struct node* h, *n; //1
  struct node *h, *n; //2
  struct node* h, n; //3
  struct node *h, n; //4
  struct node h, *n; //5
  // 1 과 2 는 포인터 변수 h, n 을 만든다는 완전히 동일한 의미
  // 3 과 4 는 포인터 변수 h, 구조체 변수 n 을 만든다는 완전히 동일한 의미
  // 즉, (1, 2) 와 (3, 4) 는 다른 의미이다.
  // 5는 구조체 변수 h, 포인터 변수 n 을 만든다는 의미
  ```

  ```c
  int a = 10;
  int a = 100; // --> 컴파일 에러
  char a = 'ten'; // --> 컴파일 에러
  // 위의 방식으로 글로벌 변수 a 를 선언한 경우
  // 같은 scope 내에서 a 라는 변수의 재선언 및 변경은 불가능함
  // 이는 이름 자체가 동일한 경우의 충돌이므로 포인터에도 동일하게 적용됨
  int *p = &a;
  
  // 이미 선언한 글로벌 변수의 값을 변경하려면 다른 scope 로 넘어가서 값을 변경하거나 그 변수 자체에 대해서 직접 변경해야함
  a = a + 1; // --> 가능
  void main() {
      a = 100; // --> 가능
  }
  void main() {
      int a = 100; // --> 가능하지만 이 값은 글로벌 a 가 변경되는 것이 아니라 아예 별개의 지역변수 a 가 생성되는 것임
  }
  ```

  ```c
  int a = 10;
  int *p = &a;
  p = 42; // --> 포인터 p 가 가리키는 주소값 자체를 42로 변경. a 값 변경 없음. 경고 발생.
  *p = 42; // --> 포인터 p 가 가리키는 값을 변경. a : 10 --> 42
  int p = 42; // --> 컴파일 에러
  int *p = 42; // --> 컴파일 에러
  ```

  

- 포인터에 NULL 을 지정한 경우
  ```c
  struct node* h = NULL;
  // 이 경우 h 에는 NULL 이라는 '아무것도 없다' 는 개념이 저장되기 때문에 자동으로 NULL 의 주소값인 0x0 등이 저장됨
  // 단순 포인터 생성처럼 & 같은것을 붙이면 오히려 일반적인 주소값이 지정되는것으로 되어 코드가 꼬일 수 있음
  ```

- 포인터 선언
  ```c
  int main() {
      int a = 42;
      int *p = &a;
      int **pp = &p;
  
      printf("a의 값 = %d\n", a);  // a 값
      printf("a의 주소 = %p\n", &a); // a 의 주소
      printf("p = a의 주소 = %p\n", p);  // p가 가리키는 주소 = a 의 주소
      printf("*p = p가 가리키는 값 = a의 주소가 가리키는 값 = a의 값 = %d\n", *p); // p가 가리키는 값 (a)
      printf("pp = p의 주소 = %p\n", pp); // pp 주소
      printf("**pp = *(*pp) = *(p의 주소가 가리키는 값) = *(p의 값) = *(a의 주소) = *p = %d\n", **pp);   // **pp = a
  }
  ```

  

  
